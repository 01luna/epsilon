/* Ask for a reentrant lexer. Otherwise Flex uses global variables, and we want
 * to avoid this behavior. */
%option reentrant

/* Normally, Flex will call yywrap when reaching an end-of-file. We don't want
 * to deal with files anyway, so let's just disable this. */
%option noyywrap

%option bison-bridge

/* Normally, on each new input file the scanner calls isatty() in an attempt to
 * determine whether the scanner's input source is interactive and thus should
 * be read a character at a time.
 * We obviously do *not* provide isatty(), and we know we're never going to use
 * an interactive input source.*/
%option never-interactive

%{

/* Flex generate a lexer, a function that outputs tokens.
 * Those tokens (and the optional value that they can be attached) are defined
 * in the Bison grammar. To use those token definitions, we need to include the
 * header generated by Bison.
 * Also, since some tokens can have an "Expression *" value attached, we'll
 * need "Expression" to be defined before including that header. */
class Expression;
#include "expression_parser.hpp"

/* Flex has provision for reading files. We'll never use this, so we're defining
 * YY_INPUT which effectively disables taking input from a file. */
#define YY_INPUT

/* Flex can print to stdout what token it matches by calling the ECHO function.
 * We don't want that feature : we don't even have printf ! */
#define ECHO

#define fprintf(...) ((void)0)
#define exit(...) abort()

%}

%%

[0-9]+ { yylval->string = yytext; return(INTEGER); }
sin {return(SINE);}
cos {return(COSINE);}
tan {return(TANGENT);}
[A-Za-z]+ { yylval->string = yytext; return(SYMBOL); }
\+ { return(PLUS); }
\- { return(MINUS); }
\* { return(MULTIPLY); }
\/ { return(DIVIDE); }
\^ { return(POW); }
\( { return(LEFT_PARENTHESIS); }
\) { return(RIGHT_PARENTHESIS); }

%%
